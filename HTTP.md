<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [HTTP](#http)
  - [网络模型](#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B)
    - [1. TCP/IP协议簇](#1-tcpip%E5%8D%8F%E8%AE%AE%E7%B0%87)
    - [2. OSI七层网络模型](#2-osi%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B)
  - [协议通信](#%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1)
    - [1. HTTP基本概念](#1-http%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
    - [2. 报文](#2-%E6%8A%A5%E6%96%87)
    - [3. HTTP1.0 HTTP1.1 HTTP2.0 HTTPS](#3-http10-http11-http20-https)
    - [4. 浏览器缓存类型](#4-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%B1%BB%E5%9E%8B)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->



## HTTP



### 网络模型

#### 1. TCP/IP协议簇

- 建立连接三次握手四次挥手.

#### 2. OSI七层网络模型



### 协议通信

#### 1. HTTP基本概念

- 一句话描述: HTTP是网络设备间的通信的标准之一, 由文本描述**报文头**和空格分割的**报文主体**, 是一种基于**TCP**的 **无状态\双向** 的**超文本**传输**协议**.

**其中的重要概念和特点**

| 概念   | 解释                                                         |
| ------ | ------------------------------------------------------------ |
| 协议   | 网络设备通信要基于同样的方法, 任何设备间需要一种规则去规范和定义这些方法, 这就是协议. |
| 超文本 | 文字、图片、音频、视频等「超文本」数据, 对应HTML超文本标记语言. |
| 无状态 | HTTP不保存请求响应的通信状态, 即不会对已完成的通信做持久化处理, 是一种轻量级的, <br />因此可以处理大量事务, 保证协议的可伸缩性. 若要管理状态可以使用Cookie等技术<br />这也是http如此流行的原因之一. |
| TCP    | TCP位于传输层, 用于提供可靠的字节流服务.<br />字节流服务指的是将大块数据分成以报文段为单位的数据包进行管理<br />因此更容易保证传输的可靠性. |
| 双向   | 这里双向指的是发送方和请求方直接进行数据传输, 基于**请求<-->响应**的形式完成通行 |
| 报文   | 报文由四部分组成: 状态行, 报文头字段, 空格, 报文主体内容     |
| 缺点   | 1. 明文传输(窃听) 2. 不验证身份(伪装); 3. 无法确保报文完整性(篡改) |

#### 2. 报文

| 请求报文                                                     | 响应报文                           |
| ------------------------------------------------------------ | ---------------------------------- |
| 请求方法: <br />GET 获取资源, POST 传输实体内容,  <br />PUT 传输文件, DELETE 删除文件<br />HEAD 获取报文首部, OPTIONS询问支持的请求方法 | 协议版本: HTTP1.1 HTTPS  websocket |
| URI (URL)  统一资源标识符 (定位符)                           | 状态码  2XX 3XX 4XX 5XX            |
| 协议版本                                                     | 原因短语 OK                        |
| 请求首部字段+通用  Accept                                    | 响应首部字段+通用  ETag            |
| 空格                                                         | 空格                               |
| 请求主体内容                                                 | 响应主体内容                       |

- 常见状态码: 连接处理结果

  | 状态码 | 原因短句              | 描述                                                         |
  | ------ | --------------------- | ------------------------------------------------------------ |
  | 1XX    |                       | 当前协议在**中转处理**中, 需要后续操作, 属于提示信息, 较少使用 |
  | 2xx    |                       | 服务器成功处理了**客户端**的请求                             |
  | 200    | OK                    | 请求成功                                                     |
  | 202    | Accepted              | 已接受, 已经接受请求，但未处理完成                           |
  | 204    | No Content            | 无内容, 服务器成功处理, 但未返回内容, 在未更新网页的情况下，可确保浏览器继续显示当前文档 |
  | 206    | Partial Content       | 部分内容。服务器成功处理了部分GET请求                        |
  | 3XX    |                       | 客户端请求的资源发送了**变动**, 需要进行**重新定向**操作     |
  | 300    | Multiple Choices      | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端 |
  | 301    | Move Permanently      | 永久移动。表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。302(暂时) |
  | 304    | Not Modified          | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制 |
  | 4XX    |                       | 客户端发送的**报文有误**，服务器无法处理                     |
  | 400    | Bad Request           | 客户端请求的语法错误，服务器无法理解                         |
  | 403    | Forbidden             | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
  | 404    | Not Found             | 服务器无法根据客户端的请求找到资源（网页）                   |
  | 5XX    |                       | **服务器**处理时内部发生了错误                               |
  | 500    | Internal Server Error | 服务器内部错误，无法完成请求                                 |
  | 501    | Not Implemented       | 服务器不支持请求的功能，无法完成请求                         |
  | 502    | Bad Gateway           | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
  | 503    | Service Unavailable   | 表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。 |
  
  - 首部行: 提供必要信息, 主要分为以下四类
  
  | 通用首部                       | 描述: 请求响应报文都会使用的首部                             |
  | ------------------------------ | ------------------------------------------------------------ |
  | Cache-Control( http1.0:Pragma) | 控制缓存行为, 防止返回过期资源 no-cache(不缓存过期资源), no-transfer(不改变主体类型) |
  | Connection                     | 管理持久连接;  控制不再转发给代理的字段 Keep-Alive(默认持续连接, 此为1.0兼容), close |
  | Upgrade                        | 升级为其他协议, 仅作用在邻接连接, 需要使用Connection控制转发  (101 switch protocols) |
  | Warining( Retry-After )        | 告知缓存相关的警告                                           |
  
  | 请求首部                       | 描述:附加客户端信息                                          |
  | ------------------------------ | ------------------------------------------------------------ |
  | Accept                         | 可接收媒体资源的类型 type/subtype                            |
  | If-Modified-Since (if条件请求) | 比较资源的更新时间, 若没有更新则返回304                      |
  | If-Match                       | 比对满足ETag的资源进行请求                                   |
  | Host                           | 必须包括在内, 请求资源的互联网主机名和端口号( 避免虚拟主机 ) |
  | User-Agent                     | HTTP客户端程序的信息, 包括浏览器\服务器\用户代理等           |
  | Max-Forwards                   | 最大跳数, 可以查看转发的代理服务器数量, 可以用来调试是服务器还是代理出问题 |
  | Referer                        | (Referrer) 告知服务器请求的发出的地址URI                     |
  
  | 响应首部      | 描述: 返回服务器处理结果相关信息               |
  | ------------- | ---------------------------------------------- |
  | ETag          | 资源实体的标识信息, 由服务器分配, 分为强弱ETag |
  | Location      | 客户端重定向指目标URI, 搭配3xx系列使用         |
  | Accept-Ranges | 是否接受字节bytes范围请求, 不能返回none        |
  
  | 实体首部     | 描述: 补充内容实体相关信息                              |
  | ------------ | ------------------------------------------------------- |
  | Allow        | 支持的HTTP方法 405 method no allowed                    |
  | Expires      | 实体主体将要过期的日期 (优先处理cache-control: max-age) |
  | Content-Type | 实体主体的媒体类型                                      |
  
  | Cookie和其他首部      | 重要的属性    | Cookie用于用户识别和状态                                   |
  | --------------------- | ------------- | ---------------------------------------------------------- |
  | Set-Cookie (响应首部) |               | 设置状态管理所使用的Cookie信息                             |
  |                       | NAME=VALUE    | 键值对信息, 必须项                                         |
  |                       | expires=DATE  | Cookie有效期(默认浏览器关闭前), 这个和expires首部是不同的! |
  |                       | domain=域名   | 设置Cookie使用的域名                                       |
  |                       | Secure        | 仅在HTTPS安全通信才进行发送                                |
  |                       | HttpOnly      | 不能被JS访问, 可用于防范XSS攻击                            |
  | Cookie (请求首部)     |               | 发送给服务器的Cookie信息                                   |
  |                       | status=enable | 让服务器开启状态管理                                       |
  | X-XSS-Protection      | 0,1           | 是否开启XSS防护(支持性不好)                                |

#### 3. HTTP1.0 HTTP1.1 HTTP2 HTTPS

- HTTP1.0 VS HTTP1.1

  ```
  http1.1 相对于 http1.0 有这样几个区别：
  （1）连接方面的区别，http1.1 默认使用持久连接，而 http1.0 默认使用非持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。
  
  （2）资源请求方面的区别，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
  
  （3）缓存方面的区别，在 http1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。
  
  （4）http1.1 中还新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，就可以将请求发往同一台服务器上的不同网站。
  
  （5）http1.1 相对于 http1.0 还新增了很多方法，如 PUT、HEAD、OPTIONS 等。
  ```

  ```
  http1.1缺点:
  	「请求 - 应答」的模式加剧了 HTTP 的性能问题。
  	虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应.这导致了请求需要排队等候, 称为队头阻塞.
  解决办法:
  	两种方法：一是减少请求数(很多网络优化都是基于此)，二是同时多开持久连接(或HTTP2的一个TCP可同时多发收)
  ```

- HTTP1.1 VS HTTP2.0

  ```
  HTTP/2改进:
  1. 二进制. HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧. 可以定义额外的帧, 且二进制解析则方便得多.
  2. 多工(双向的、实时的通信).  HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"
  3. 数据流. HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应.
  4. 头信息压缩. 头信息使用gzip或compress压缩后再发送, 另一方面，客户端和服务器同时维护一张头信息表, 所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号
  5. 服务器推送. HTTP/2 允许服务器未经请求，主动向客户端发送资源. 如将一些静态资源主动发送.
  ```

  ```
  HTTP/2 协议缺点:
  因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。由于多个数据流使用同一个 TCP 连接，遵 守同一个流量状态控制和拥塞控制。只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的所有数据都 会被阻塞。HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题，与它本身的实现其实并没有多大关系。
  
  HTTP/3 协议
  由于 TCP 本身存在的一些限制，Google 就开发了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。 QUIC 协议在 UDP 协议上实现了多路复用、有序交付、重传等等功能
  ```

- HTTP 与 HTTPs

  ```
  HTTPS = HTTP + 加密处理 + 认证 + 完整性保护
  HTTPS是基于HTTP开发的, 将部分通信接口用SSL和TSL协议进行替代. 本质就是再HTTP和TCP之间增加了一层SSL安全协议.
  1. 加密处理: 使用了混合加密机制, 利用非对称的公钥加密传输共享密匙, 之后再建立对称加密的共享加密
  2. 认证: 加入了公钥证书和CA来验证对方身份有效性
  3. 完整性: 摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险
  3. HTTP 的端口号是 80，HTTPS 的端口号是 443。
  ```

  ```
  HTTPS缺点:
  耗能. 由于使用到加密通信, 建立TSl连接会导致通信变慢, 同时需要消耗CPU和内存对数据进行加密处理
  ```

书籍: 图解HTTP

[HTTP入门--阮一峰](http://www.ruanyifeng.com/blog/2016/08/http.html)

[硬核！30 张图解 HTTP 常见的面试题](https://zhuanlan.zhihu.com/p/111716047)

#### 4. 浏览器缓存类型

