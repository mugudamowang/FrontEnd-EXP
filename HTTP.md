<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [HTTP](#http)
  - [网络模型](#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B)
    - [1. TCP/IP协议簇](#1-tcpip%E5%8D%8F%E8%AE%AE%E7%B0%87)
    - [2. TCP三次握手四次挥手](#2-tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)
    - [2. OSI七层网络模型](#2-osi%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B)
  - [HTTP协议](#http%E5%8D%8F%E8%AE%AE)
    - [1. HTTP基本概念](#1-http%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
    - [2. 报文](#2-%E6%8A%A5%E6%96%87)
    - [3. HTTP1.0 HTTP1.1 HTTP2 HTTPS](#3-http10-http11-http2-https)
    - [4. 浏览器缓存类型](#4-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%B1%BB%E5%9E%8B)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->



## HTTP



### 网络模型

#### 1. TCP/UDP

TCP 协议是面向连接的，提供可靠数据传输服务的传输层协议。

UDP 是一种无连接的，不可靠的传输层协议。它只提供了传输层需要实现的最低限度的功能，除了复用/分解功能和少量的差 错检测外，它几乎没有对 IP 增加其他的东西。UDP 协议适用于对实时性要求高的应用场景。

#### 2. TCP三次握手四次挥手

**TCP三次握手**是指的是通信双方进行序列号确认并建立链接的过程.

**主要过程**为:

- 第一次握手--客户端发送SYN报文: 客户端设置初始化序列号, 然后设置SYN标志位为1发送到服务端
- 第二次握手--服务端接受SYN报文, 返回SYN+ACK报文: 服务端接收到SYN也初始化自己的序列号, 并设置SYN和ACK位为1, 确认应答号设置为客户端序列号+1, 发送.
- 第三次握手--客户端发送应答报文: 客户端接收到服务端的应答报文, 也要向服务端发送一个ACK应答报文, 设置ACK为1, 确认应答号为服务端序列号+1, 发送, 建立连接

**常见要点:**

- 第三次握手可以携带数据信息
- 为什么是三次握手? 三次才能保证双方具有接收和发送的能力.
  1. 首要原因是为了防止历史连接重复初始化; 如果序列号过期, 那么就可以在第三次握手发送RST终止连接
  2. 同步双方的序列号; 通过一来一回确认客户端和服务器的序列号, 一共四次, 其中服务端发送确认序列号和初始化序列号可以合并, 故为三次. 确认序列号主要可以确保传输的有序, 标识接受的数据等.
  3. 避免资源浪费; 如果没有第三次握手, 遇到网络阻塞时客户端发送多个SYN报文而服务器无法确认接受状态, 之间建立连接就会导致冗余无效连接, 造成浪费.

**TCP四次挥手**是双方都可以主动断开连接，断开连接后主机中的「资源」将被释放的过程. 本质上是差不多的, 都是双方互相确认的过程.

客户端主动关闭连接 —— TCP 四次挥手

- 客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
- 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSED_WAIT` 状态。
- 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
- 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
- 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
- 服务器收到了 `ACK` 应答报文后，就进入了 `CLOSED` 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSED` 状态，至此客户端也完成连接的关闭。

**常见要点:**

- 但为什么不是**三次挥手而是四次挥手**? 
  - 客户端向服务端发送FIN请求关闭时, 表示客户端不再发送数据, 但连接还在, 还能进行数据传输
  - 服务端不像在三次握手中那样, 它不合并ACK位和FIN位, 因为此时可能还有数据在传输, 需要进行善后处理之侯再发送FIN位.
- **为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？**
  - 为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。
  - 防止收到旧的数据包. 当网络延迟导致数据包在关闭前都没有抵达, 那么重用这个TCP端口时, 这时旧的数据抵达会造成数据混乱, 加入2MSL的等待时间可以让延迟的数据包失效.

| 名词       | 解释                                                         |
| ---------- | ------------------------------------------------------------ |
| 序列号     | 建立连接时计算机生成的随机数字, 通过SYN包传递, 每发送一次就+1,; 可以用来**保证传输的顺序**. |
| 确认应答号 | 发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收, 相当于一个确认信息. 用来**保证不丢包** |
| 控制位     | *ACK*：该位为 `1` 时, 「确认应答」的字段变为有效, TCP 规定除了最初建立连接时的 `SYN` 包之外该位必须设置为 `1` <br />*RST*：该位为 `1` 时, 表示 TCP 连接中出现异常必须强制断开连接.  <br />*SYN*：该位为 `1` 时, 表示希望建立连接, 并在其「序列号」的字段进行序列号初始值的设定. <br /> *FIN*：该位为 `1` 时, 表示今后不会再有数据发送, 希望断开连接. 当通信结束希望断开连接时, 通信双方的主机之间就可以相互交换 `FIN` 位为 1 的 TCP 段. |

[35 张图解：被问千百遍的 TCP 三次握手和四次挥手面试题](https://www.cnblogs.com/xiaolincoding/p/12638546.html)

#### 2. OSI七层网络模型



### HTTP协议

#### 1. HTTP基本概念

- 一句话描述: HTTP是网络设备间的通信的标准之一, 由文本描述**报文头**和空格分割的**报文主体**, 是一种基于**TCP**的 **无状态\双向** 的**超文本**传输**协议**.

**其中的重要概念和特点**

| 概念   | 解释                                                         |
| ------ | ------------------------------------------------------------ |
| 协议   | 网络设备通信要基于同样的方法, 任何设备间需要一种规则去规范和定义这些方法, 这就是协议. |
| 超文本 | 文字、图片、音频、视频等「超文本」数据, 对应HTML超文本标记语言. |
| 无状态 | HTTP不保存请求响应的通信状态, 即不会对已完成的通信做持久化处理, 是一种轻量级的, <br />因此可以处理大量事务, 保证协议的可伸缩性. 若要管理状态可以使用Cookie等技术<br />这也是http如此流行的原因之一. |
| TCP    | TCP位于传输层, 用于提供可靠的字节流服务.<br />字节流服务指的是将大块数据分成以报文段为单位的数据包进行管理<br />因此更容易保证传输的可靠性. |
| 双向   | 这里双向指的是发送方和请求方直接进行数据传输, 基于**请求<-->响应**的形式完成通行 |
| 报文   | 报文由四部分组成: 状态行, 报文头字段, 空格, 报文主体内容     |
| 缺点   | 1. 明文传输(窃听) 2. 不验证身份(伪装); 3. 无法确保报文完整性(篡改) |

#### 2. 报文

| 请求报文                                                     | 响应报文                           |
| ------------------------------------------------------------ | ---------------------------------- |
| 请求方法: <br />GET 获取资源, POST 传输实体内容,  <br />PUT 传输文件, DELETE 删除文件<br />HEAD 获取报文首部, OPTIONS询问支持的请求方法 | 协议版本: HTTP1.1 HTTPS  websocket |
| URI (URL)  统一资源标识符 (定位符)                           | 状态码  2XX 3XX 4XX 5XX            |
| 协议版本                                                     | 原因短语 OK                        |
| 请求首部字段+通用  Accept                                    | 响应首部字段+通用  ETag            |
| 空格                                                         | 空格                               |
| 请求主体内容                                                 | 响应主体内容                       |

- 常见状态码: 连接处理结果

  | 状态码 | 原因短句              | 描述                                                         |
  | ------ | --------------------- | ------------------------------------------------------------ |
  | 1XX    |                       | 当前协议在**中转处理**中, 需要后续操作, 属于提示信息, 较少使用 |
  | 2xx    |                       | 服务器成功处理了**客户端**的请求                             |
  | 200    | OK                    | 请求成功                                                     |
  | 202    | Accepted              | 已接受, 已经接受请求, 但未处理完成                           |
  | 204    | No Content            | 无内容, 服务器成功处理, 但未返回内容, 在未更新网页的情况下, 可确保浏览器继续显示当前文档 |
  | 206    | Partial Content       | 部分内容. 服务器成功处理了部分GET请求                        |
  | 3XX    |                       | 客户端请求的资源发送了**变动**, 需要进行**重新定向**操作     |
  | 300    | Multiple Choices      | 多种选择. 请求的资源可包括多个位置, 相应可返回一个资源特征与地址的列表用于用户终端 |
  | 301    | Move Permanently      | 永久移动. 表示永久重定向, 说明请求的资源已经不存在了, 需改用新的 URL 再次访问. 302(暂时) |
  | 304    | Not Modified          | 未修改. 所请求的资源未修改, 服务器返回此状态码时, 不会返回任何资源. 重定向已存在的缓冲文件, 也称缓存重定向, 用于缓存控制 |
  | 4XX    |                       | 客户端发送的**报文有误**, 服务器无法处理                     |
  | 400    | Bad Request           | 客户端请求的语法错误, 服务器无法理解                         |
  | 403    | Forbidden             | 服务器理解请求客户端的请求, 但是拒绝执行此请求               |
  | 404    | Not Found             | 服务器无法根据客户端的请求找到资源（网页）                   |
  | 5XX    |                       | **服务器**处理时内部发生了错误                               |
  | 500    | Internal Server Error | 服务器内部错误, 无法完成请求                                 |
  | 501    | Not Implemented       | 服务器不支持请求的功能, 无法完成请求                         |
  | 502    | Bad Gateway           | 作为网关或者代理工作的服务器尝试执行请求时, 从远程服务器接收到了一个无效的响应 |
  | 503    | Service Unavailable   | 表示服务器当前很忙, 暂时无法响应服务器, 类似“网络服务正忙, 请稍后重试”的意思. |
  
  - 首部行: 提供必要信息, 主要分为以下四类
  
  | 通用首部                       | 描述: 请求响应报文都会使用的首部                             |
  | ------------------------------ | ------------------------------------------------------------ |
  | Cache-Control( http1.0:Pragma) | 控制缓存行为, 防止返回过期资源 no-cache(不缓存过期资源), no-transfer(不改变主体类型) |
  | Connection                     | 管理持久连接;  控制不再转发给代理的字段 Keep-Alive(默认持续连接, 此为1.0兼容), close |
  | Upgrade                        | 升级为其他协议, 仅作用在邻接连接, 需要使用Connection控制转发  (101 switch protocols) |
  | Warining( Retry-After )        | 告知缓存相关的警告                                           |
  
  | 请求首部                       | 描述:附加客户端信息                                          |
  | ------------------------------ | ------------------------------------------------------------ |
  | Accept                         | 可接收媒体资源的类型 type/subtype                            |
  | If-Modified-Since (if条件请求) | 比较资源的更新时间, 若没有更新则返回304                      |
  | If-Match                       | 比对满足ETag的资源进行请求                                   |
  | Host                           | 必须包括在内, 请求资源的互联网主机名和端口号( 避免虚拟主机 ) |
  | User-Agent                     | HTTP客户端程序的信息, 包括浏览器\服务器\用户代理等           |
  | Max-Forwards                   | 最大跳数, 可以查看转发的代理服务器数量, 可以用来调试是服务器还是代理出问题 |
  | Referer                        | (Referrer) 告知服务器请求的发出的地址URI                     |
  
  | 响应首部      | 描述: 返回服务器处理结果相关信息               |
  | ------------- | ---------------------------------------------- |
  | ETag          | 资源实体的标识信息, 由服务器分配, 分为强弱ETag |
  | Location      | 客户端重定向指目标URI, 搭配3xx系列使用         |
  | Accept-Ranges | 是否接受字节bytes范围请求, 不能返回none        |
  
  | 实体首部     | 描述: 补充内容实体相关信息                              |
  | ------------ | ------------------------------------------------------- |
  | Allow        | 支持的HTTP方法 405 method no allowed                    |
  | Expires      | 实体主体将要过期的日期 (优先处理cache-control: max-age) |
  | Content-Type | 实体主体的媒体类型                                      |
  
  | Cookie和其他首部      | 重要的属性    | Cookie用于用户识别和状态                                     |
  | --------------------- | ------------- | ------------------------------------------------------------ |
  | Set-Cookie (响应首部) |               | 设置状态管理所使用的Cookie信息                               |
  |                       | NAME=VALUE    | 键值对信息, 必须项                                           |
  |                       | expires=DATE  | Cookie有效期的时间戳(默认浏览器关闭前), 这个和expires首部是不同的! 绝对时间 |
  |                       | domain=域名   | 设置Cookie使用的域名                                         |
  |                       | Secure        | 仅在HTTPS安全通信才进行发送                                  |
  |                       | HttpOnly      | 不能被JS访问, 可用于防范XSS攻击                              |
  |                       | Max-Age       | 与expires作用相同, 用来告诉浏览器此cookie多久过期, 相对时间  |
  | Cookie (请求首部)     |               | 发送给服务器的Cookie信息                                     |
  |                       | status=enable | 让服务器开启状态管理                                         |
  | X-XSS-Protection      | 0,1           | 是否开启XSS防护(支持性不好)                                  |

#### 3. HTTP1.0 HTTP1.1 HTTP2 HTTPS

- HTTP1.0 VS HTTP1.1

  ```
  http1.1 相对于 http1.0 有这样几个区别：
  （1）连接方面的区别，http1.1 默认使用持久连接, 而 http1.0 默认使用非持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接, 以此来避免使用非持久连接时每次需要建立连接的时延. 
  
  （2）资源请求方面的区别, 在 http1.0 中, 存在一些浪费带宽的现象, 例如客户端只是需要某个对象的一部分, 而服务器却将整个对象送过来了, 并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域, 它允许只请求资源的某个部分, 即返回码是 206（Partial Content）, 这样就方便了开发者自由的选择以便于充分利用带宽和连接. 
  
  （3）缓存方面的区别, 在 http1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略. 
  
  （4）http1.1 中还新增了 host 字段, 用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址, 因此, 请求消息中的 URL 并没有传递主机名（hostname）. 但随着虚拟主机技术的发展, 在一台物理服务器上可以存在多个虚拟主机, 并且它们共享一个IP地址. 因此有了 host 字段, 就可以将请求发往同一台服务器上的不同网站. 
  
  （5）http1.1 相对于 http1.0 还新增了很多方法, 如 PUT、HEAD、OPTIONS 等. 
  ```

  ```
  http1.1缺点:
  	「请求 - 应答」的模式加剧了 HTTP 的性能问题. 
  	虽然1.1版允许复用TCP连接, 但是同一个TCP连接里面, 所有的数据通信是按次序进行的. 服务器只有处理完一个回应, 才会进行下一个回应.这导致了请求需要排队等候, 称为队头阻塞.
  解决办法:
  	两种方法：一是减少请求数(很多网络优化都是基于此), 二是同时多开持久连接(或HTTP2的一个TCP可同时多发收)
  ```

- HTTP1.1 VS HTTP2.0

  ```
  HTTP/2改进:
  1. 二进制. HTTP/2 则是一个彻底的二进制协议, 头信息和数据体都是二进制, 并且统称为"帧"（frame）：头信息帧和数据帧. 可以定义额外的帧, 且二进制解析则方便得多.
  2. 多工(双向的、实时的通信).  HTTP/2 复用TCP连接, 在一个连接里, 客户端和浏览器都可以同时发送多个请求或回应, 而且不用按照顺序一一对应, 这样就避免了"队头堵塞"
  3. 数据流. HTTP/2 的数据包是不按顺序发送的, 同一个连接里面连续的数据包, 可能属于不同的回应.
  4. 头信息压缩. 头信息使用gzip或compress压缩后再发送, 另一方面, 客户端和服务器同时维护一张头信息表, 所有字段都会存入这个表, 生成一个索引号, 以后就不发送同样字段了, 只发送索引号
  5. 服务器推送. HTTP/2 允许服务器未经请求, 主动向客户端发送资源. 如将一些静态资源主动发送.
  ```

  ```
  HTTP/2 协议缺点:
  因为 HTTP/2 使用了多路复用, 一般来说同一域名下只需要使用一个 TCP 连接. 由于多个数据流使用同一个 TCP 连接, 遵 守同一个流量状态控制和拥塞控制. 只要一个数据流遭遇到拥塞, 剩下的数据流就没法发出去, 这样就导致了后面的所有数据都 会被阻塞。HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题, 与它本身的实现其实并没有多大关系. 
  
  HTTP/3 协议
  由于 TCP 本身存在的一些限制，Google 就开发了一个基于 UDP 协议的 QUIC 协议, 并且使用在了 HTTP/3 上.  QUIC 协议在 UDP 协议上实现了多路复用、有序交付、重传等等功能
  ```

- HTTP 与 HTTPs

  ```
  HTTPS = HTTP + 加密处理 + 认证 + 完整性保护
  HTTPS是基于HTTP开发的, 将部分通信接口用SSL和TSL协议进行替代. 本质就是再HTTP和TCP之间增加了一层SSL安全协议.
  1. 加密处理: 使用了混合加密机制, 利用非对称的公钥加密传输共享密匙, 之后再建立对称加密的共享加密
  2. 认证: 加入了公钥证书和CA来验证对方身份有效性
  3. 完整性: 摘要算法的方式来实现完整性, 它能够为数据生成独一无二的「指纹」, 指纹用于校验数据的完整性, 解决了篡改的风险
  3. HTTP 的端口号是 80，HTTPS 的端口号是 443。
  ```

  ```
  HTTPS缺点:
  耗能. 由于使用到加密通信, 建立TSl连接会导致通信变慢, 同时需要消耗CPU和内存对数据进行加密处理
  ```

书籍: 图解HTTP

[HTTP入门--阮一峰](http://www.ruanyifeng.com/blog/2016/08/http.html)

[硬核！30 张图解 HTTP 常见的面试题](https://zhuanlan.zhihu.com/p/111716047)

#### 4. 浏览器缓存类型

#### 5. CDN内容分发网络

CDN指的是内容分发网络, 通过分散在不同地理位置上的服务器间的协作, 达到就近访问, 内容快速交付的功能. CDN可以加速提供互联网资源的能力, 比如一些图片\HTML\JS脚本等静态资源可以利用CDN进行定位转发, 并定位到距离请求最近的位置上, 将相应的资源转发给用户. 

一来提高了访问速度, 而来减轻了原服务器的渲染压力, 减少带宽成本. 

此外CDN不依托网络主机, 他们可以避免网络攻击的骚扰. 

[什么是CDN](https://www.cloudflare.com/zh-cn/learning/cdn/what-is-a-cdn/)